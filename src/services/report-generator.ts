import { GitHubIssue, Config } from "../models";
import * as fs from "fs-extra";
import * as path from "path";

export interface ReportMetadata {
  repositoryName: string;
  repositoryUrl: string;
  productArea: string;
  scrapeDate: Date;
  totalIssuesAnalyzed: number;
  relevantIssuesFound: number;
  minRelevanceScore: number;
  generatedBy: string;
}

export interface ReportGenerationOptions {
  includeTableOfContents?: boolean;
  sortByRelevance?: boolean;
  includeMetadata?: boolean;
  customTemplate?: string;
}

export class ReportGenerator {
  private readonly defaultOptions: Required<ReportGenerationOptions> = {
    includeTableOfContents: true,
    sortByRelevance: true,
    includeMetadata: true,
    customTemplate: "",
  };

  /**
   * Generate a comprehensive markdown report from GitHub issues
   */
  async generateReport(
    issues: GitHubIssue[],
    metadata: ReportMetadata,
    config: Config,
    options: ReportGenerationOptions = {}
  ): Promise<string> {
    const opts = { ...this.defaultOptions, ...options };

    // Sort issues if requested
    const sortedIssues = opts.sortByRelevance
      ? this.sortIssuesByRelevance(issues)
      : issues;

    let report = "";

    // Generate header
    report += this.generateHeader(metadata);

    // Generate metadata section
    if (opts.includeMetadata) {
      report += this.generateMetadataSection(metadata);
    }

    // Generate table of contents
    if (opts.includeTableOfContents) {
      report += this.generateTableOfContents(sortedIssues);
    }

    // Generate issues section
    report += this.generateIssuesSection(sortedIssues);

    return report;
  }

  /**
   * Save report to file with proper naming convention
   */
  async saveReport(
    report: string,
    metadata: ReportMetadata,
    outputPath: string
  ): Promise<string> {
    // Ensure output directory exists
    await fs.ensureDir(outputPath);

    // Generate filename based on repository and product area
    const filename = this.generateFilename(metadata);
    const fullPath = path.join(outputPath, filename);

    // Write report to file
    await fs.writeFile(fullPath, report, "utf8");

    return fullPath;
  }

  /**
   * Generate filename based on repository and product area
   */
  private generateFilename(metadata: ReportMetadata): string {
    const repoName = metadata.repositoryName
      .toLowerCase()
      .replace(/[^a-z0-9]/g, "-");

    const productArea = metadata.productArea
      .toLowerCase()
      .replace(/[^a-z0-9]/g, "-")
      .substring(0, 30); // Limit length

    const timestamp = metadata.scrapeDate.toISOString().split("T")[0]; // YYYY-MM-DD format

    return `github-issues-${repoName}-${productArea}-${timestamp}.md`;
  }

  /**
   * Sort issues by relevance score (highest first)
   */
  private sortIssuesByRelevance(issues: GitHubIssue[]): GitHubIssue[] {
    return [...issues].sort((a, b) => b.relevanceScore - a.relevanceScore);
  }

  /**
   * Generate report header
   */
  private generateHeader(metadata: ReportMetadata): string {
    return `# GitHub Issues Report: ${metadata.repositoryName} - ${metadata.productArea}

`;
  }

  /**
   * Generate metadata section
   */
  private generateMetadataSection(metadata: ReportMetadata): string {
    return `## Summary

- **Repository**: [${metadata.repositoryName}](${metadata.repositoryUrl})
- **Product Area**: ${metadata.productArea}
- **Total Issues Analyzed**: ${metadata.totalIssuesAnalyzed}
- **Relevant Issues Found**: ${metadata.relevantIssuesFound}
- **Minimum Relevance Score**: ${metadata.minRelevanceScore}%
- **Report Generated**: ${metadata.scrapeDate.toLocaleString()}
- **Generated By**: ${metadata.generatedBy}

`;
  }

  /**
   * Generate table of contents
   */
  private generateTableOfContents(issues: GitHubIssue[]): string {
    if (issues.length === 0) {
      return `## Table of Contents

*No relevant issues found.*

`;
    }

    let toc = `## Table of Contents

`;

    issues.forEach((issue, index) => {
      const anchor = this.generateAnchor(issue.title);
      toc += `${index + 1}. [Issue #${issue.id}: ${issue.title}](#${anchor}) (${
        issue.relevanceScore
      }% relevance)\n`;
    });

    toc += "\n";
    return toc;
  }

  /**
   * Generate issues section
   */
  private generateIssuesSection(issues: GitHubIssue[]): string {
    if (issues.length === 0) {
      return `## Issues

*No relevant issues found. Consider broadening your search criteria or lowering the minimum relevance score.*

`;
    }

    let section = `## Issues

`;

    issues.forEach((issue, index) => {
      section += this.formatIssue(issue, index + 1);
      section += "\n---\n\n";
    });

    return section;
  }

  /**
   * Format individual issue
   */
  private formatIssue(issue: GitHubIssue, index: number): string {
    let formatted = `### ${index}. Issue #${issue.id}: ${issue.title}

`;

    // Basic information
    formatted += `**Status**: ${
      issue.state.charAt(0).toUpperCase() + issue.state.slice(1)
    }\n`;
    formatted += `**Created**: ${issue.createdAt.toLocaleDateString()} by ${
      issue.author
    }\n`;
    formatted += `**Last Updated**: ${issue.updatedAt.toLocaleDateString()}\n`;
    formatted += `**Relevance Score**: ${issue.relevanceScore}/100\n`;
    formatted += `**URL**: [View on GitHub](${issue.url})\n`;

    // Labels
    if (issue.labels.length > 0) {
      formatted += `**Labels**: ${issue.labels
        .map((label) => `\`${label}\``)
        .join(", ")}\n`;
    }

    formatted += "\n";

    // Summary
    if (issue.summary) {
      formatted += `#### Summary\n\n${issue.summary}\n\n`;
    }

    // Description (truncated if too long)
    if (issue.description) {
      const truncatedDescription = this.truncateText(issue.description, 500);
      formatted += `#### Description\n\n${truncatedDescription}\n\n`;
    }

    // Workarounds
    if (issue.workarounds.length > 0) {
      formatted += `#### Workarounds\n\n`;

      issue.workarounds.forEach((workaround, idx) => {
        const authorTypeIcon = this.getAuthorTypeIcon(workaround.authorType);
        const effectivenessIcon = this.getEffectivenessIcon(
          workaround.effectiveness
        );

        formatted += `${idx + 1}. **${authorTypeIcon} ${
          workaround.author
        }** ${effectivenessIcon}\n`;
        formatted += `   ${workaround.description}\n\n`;
      });
    } else {
      formatted += `#### Workarounds\n\n*No workarounds found in the comments.*\n\n`;
    }

    return formatted;
  }

  /**
   * Generate anchor for table of contents
   */
  private generateAnchor(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, "")
      .replace(/\s+/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-|-$/g, "");
  }

  /**
   * Truncate text to specified length
   */
  private truncateText(text: string, maxLength: number): string {
    if (text.length <= maxLength) {
      return text;
    }

    const truncated = text.substring(0, maxLength);
    const lastSpace = truncated.lastIndexOf(" ");

    if (lastSpace > maxLength * 0.8) {
      return truncated.substring(0, lastSpace) + "...";
    }

    return truncated + "...";
  }

  /**
   * Get icon for author type
   */
  private getAuthorTypeIcon(authorType: string): string {
    switch (authorType) {
      case "maintainer":
        return "üë®‚Äçüíª";
      case "contributor":
        return "ü§ù";
      case "user":
        return "üë§";
      default:
        return "‚ùì";
    }
  }

  /**
   * Get icon for effectiveness
   */
  private getEffectivenessIcon(effectiveness: string): string {
    switch (effectiveness) {
      case "confirmed":
        return "‚úÖ";
      case "suggested":
        return "üí°";
      case "partial":
        return "‚ö†Ô∏è";
      default:
        return "‚ùì";
    }
  }

  /**
   * Create report metadata from config and issues
   */
  static createMetadata(
    config: Config,
    issues: GitHubIssue[],
    totalAnalyzed: number
  ): ReportMetadata {
    const repoUrl = config.repository.startsWith("http")
      ? config.repository
      : `https://github.com/${config.repository}`;

    const repoName = config.repository.includes("/")
      ? config.repository.split("/").pop() || config.repository
      : config.repository;

    return {
      repositoryName: repoName,
      repositoryUrl: repoUrl,
      productArea: config.productArea,
      scrapeDate: new Date(),
      totalIssuesAnalyzed: totalAnalyzed,
      relevantIssuesFound: issues.length,
      minRelevanceScore: config.minRelevanceScore,
      generatedBy: "GitHub Issue Scraper v1.0.0",
    };
  }
}
