import { ReportGenerator, ReportMetadata } from "../report-generator";
import { GitHubIssue, Config } from "../../models";

describe("ReportGenerator", () => {
  let reportGenerator: ReportGenerator;
  let mockIssues: GitHubIssue[];
  let mockMetadata: ReportMetadata;
  let mockConfig: Config;

  beforeEach(() => {
    reportGenerator = new ReportGenerator();

    // Mock data
    mockIssues = [
      {
        id: 123,
        title: "Authentication fails with OAuth",
        description:
          "Users are experiencing authentication failures when using OAuth flow. This is a critical issue affecting user login.",
        labels: ["bug", "authentication", "critical"],
        state: "open",
        createdAt: new Date("2024-01-15"),
        updatedAt: new Date("2024-01-20"),
        author: "user123",
        url: "https://github.com/test/repo/issues/123",
        comments: [],
        relevanceScore: 85,
        summary: "Critical authentication bug affecting OAuth login flow",
        workarounds: [
          {
            description: "Use API key authentication as temporary workaround",
            author: "maintainer1",
            authorType: "maintainer",
            commentId: 456,
            effectiveness: "confirmed",
          },
          {
            description: "Clear browser cache and try again",
            author: "user456",
            authorType: "user",
            commentId: 789,
            effectiveness: "suggested",
          },
        ],
      },
      {
        id: 456,
        title: "Performance issue with large datasets",
        description:
          "Application becomes slow when processing datasets larger than 10MB",
        labels: ["performance", "enhancement"],
        state: "open",
        createdAt: new Date("2024-01-10"),
        updatedAt: new Date("2024-01-18"),
        author: "developer1",
        url: "https://github.com/test/repo/issues/456",
        comments: [],
        relevanceScore: 72,
        summary: "Performance degradation with large data processing",
        workarounds: [],
      },
    ];

    mockMetadata = {
      repositoryName: "test-repo",
      repositoryUrl: "https://github.com/test/test-repo",
      productArea: "authentication",
      scrapeDate: new Date("2024-01-25T10:00:00Z"),
      totalIssuesAnalyzed: 100,
      relevantIssuesFound: 2,
      minRelevanceScore: 70,
      generatedBy: "GitHub Issue Scraper v1.0.0",
    };

    mockConfig = {
      githubToken: "test-token",
      repository: "test/test-repo",
      productArea: "authentication",
      maxIssues: 50,
      minRelevanceScore: 70,
      outputPath: "./reports",
    };
  });

  describe("generateReport", () => {
    it("should generate a complete report with all sections", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain(
        "# GitHub Issues Report: test-repo - authentication"
      );
      expect(report).toContain("## Summary");
      expect(report).toContain("## Table of Contents");
      expect(report).toContain("## Issues");
      expect(report).toContain("Issue #123: Authentication fails with OAuth");
      expect(report).toContain(
        "Issue #456: Performance issue with large datasets"
      );
    });

    it("should include metadata section with correct information", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain(
        "**Repository**: [test-repo](https://github.com/test/test-repo)"
      );
      expect(report).toContain("**Product Area**: authentication");
      expect(report).toContain("**Total Issues Analyzed**: 100");
      expect(report).toContain("**Relevant Issues Found**: 2");
      expect(report).toContain("**Minimum Relevance Score**: 70%");
      expect(report).toContain("**Generated By**: GitHub Issue Scraper v1.0.0");
    });

    it("should generate table of contents with correct links", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain(
        "1. [Issue #123: Authentication fails with OAuth](#authentication-fails-with-oauth) (85% relevance)"
      );
      expect(report).toContain(
        "2. [Issue #456: Performance issue with large datasets](#performance-issue-with-large-datasets) (72% relevance)"
      );
    });

    it("should sort issues by relevance score by default", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      const issue123Index = report.indexOf("Issue #123");
      const issue456Index = report.indexOf("Issue #456");

      // Issue 123 has higher relevance (85) so should come first
      expect(issue123Index).toBeLessThan(issue456Index);
    });

    it("should format issues with all required information", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      // Check issue formatting
      expect(report).toContain("**Status**: Open");
      expect(report).toContain("**Created**: 1/15/2024 by user123");
      expect(report).toContain("**Relevance Score**: 85/100");
      expect(report).toContain(
        "**Labels**: `bug`, `authentication`, `critical`"
      );
      expect(report).toContain(
        "**URL**: [View on GitHub](https://github.com/test/repo/issues/123)"
      );
    });

    it("should include workarounds with proper formatting", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain("#### Workarounds");
      expect(report).toContain("1. **👨‍💻 maintainer1** ✅");
      expect(report).toContain(
        "Use API key authentication as temporary workaround"
      );
      expect(report).toContain("2. **👤 user456** 💡");
      expect(report).toContain("Clear browser cache and try again");
    });

    it("should handle issues without workarounds", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      // Issue 456 has no workarounds
      const issue456Section = report.substring(report.indexOf("Issue #456"));
      expect(issue456Section).toContain(
        "*No workarounds found in the comments.*"
      );
    });

    it("should handle empty issues array", async () => {
      const emptyMetadata = {
        ...mockMetadata,
        relevantIssuesFound: 0,
      };

      const report = await reportGenerator.generateReport(
        [],
        emptyMetadata,
        mockConfig
      );

      expect(report).toContain("*No relevant issues found.*");
      expect(report).toContain(
        "*No relevant issues found. Consider broadening your search criteria or lowering the minimum relevance score.*"
      );
    });

    it("should respect options to exclude table of contents", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig,
        { includeTableOfContents: false }
      );

      expect(report).not.toContain("## Table of Contents");
    });

    it("should respect options to exclude metadata", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig,
        { includeMetadata: false }
      );

      expect(report).not.toContain("- **Repository**:");
      expect(report).not.toContain("- **Product Area**:");
      expect(report).not.toContain("- **Total Issues Analyzed**:");
    });

    it("should not sort by relevance when option is disabled", async () => {
      // Reverse the order to test
      const reversedIssues = [...mockIssues].reverse();

      const report = await reportGenerator.generateReport(
        reversedIssues,
        mockMetadata,
        mockConfig,
        { sortByRelevance: false }
      );

      const issue456Index = report.indexOf("1. Issue #456");
      const issue123Index = report.indexOf("2. Issue #123");

      expect(issue456Index).toBeLessThan(issue123Index);
    });
  });

  describe("filename generation", () => {
    it("should generate correct filename", () => {
      const filename = (reportGenerator as any).generateFilename(mockMetadata);
      const expectedFilename =
        "github-issues-test-repo-authentication-2024-01-25.md";
      expect(filename).toBe(expectedFilename);
    });

    it("should handle special characters in repository name", () => {
      const specialMetadata = {
        ...mockMetadata,
        repositoryName: "test@repo#name!",
        productArea: "auth & security",
      };

      const filename = (reportGenerator as any).generateFilename(
        specialMetadata
      );
      expect(filename).toContain(
        "github-issues-test-repo-name--auth---security-2024-01-25.md"
      );
    });
  });

  describe("createMetadata", () => {
    it("should create metadata from config and issues", () => {
      const metadata = ReportGenerator.createMetadata(
        mockConfig,
        mockIssues,
        150
      );

      expect(metadata.repositoryName).toBe("test-repo");
      expect(metadata.repositoryUrl).toBe("https://github.com/test/test-repo");
      expect(metadata.productArea).toBe("authentication");
      expect(metadata.totalIssuesAnalyzed).toBe(150);
      expect(metadata.relevantIssuesFound).toBe(2);
      expect(metadata.minRelevanceScore).toBe(70);
      expect(metadata.generatedBy).toBe("GitHub Issue Scraper v1.0.0");
      expect(metadata.scrapeDate).toBeInstanceOf(Date);
    });

    it("should handle repository URL formats", () => {
      const configWithUrl = {
        ...mockConfig,
        repository: "https://github.com/owner/repo",
      };

      const metadata = ReportGenerator.createMetadata(
        configWithUrl,
        mockIssues,
        100
      );

      expect(metadata.repositoryUrl).toBe("https://github.com/owner/repo");
      expect(metadata.repositoryName).toBe("repo");
    });

    it("should handle simple repository names", () => {
      const configWithSimpleName = {
        ...mockConfig,
        repository: "simple-repo",
      };

      const metadata = ReportGenerator.createMetadata(
        configWithSimpleName,
        mockIssues,
        100
      );

      expect(metadata.repositoryName).toBe("simple-repo");
      expect(metadata.repositoryUrl).toBe("https://github.com/simple-repo");
    });
  });

  describe("text truncation", () => {
    it("should truncate long descriptions", async () => {
      const longDescription = "A".repeat(1000);
      const issueWithLongDescription = {
        ...mockIssues[0],
        description: longDescription,
      };

      const report = await reportGenerator.generateReport(
        [issueWithLongDescription],
        mockMetadata,
        mockConfig
      );

      expect(report).toContain("...");
      expect(report).not.toContain("A".repeat(600));
    });
  });

  describe("author type and effectiveness icons", () => {
    it("should use correct icons for different author types", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain("👨‍💻"); // maintainer
      expect(report).toContain("👤"); // user
    });

    it("should use correct icons for different effectiveness levels", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain("✅"); // confirmed
      expect(report).toContain("💡"); // suggested
    });
  });

  describe("error handling", () => {
    let mockFs: any;

    beforeEach(() => {
      // Mock fs-extra
      mockFs = {
        ensureDir: jest.fn(),
        writeFile: jest.fn(),
        access: jest.fn(),
        stat: jest.fn(),
        move: jest.fn(),
        readFile: jest.fn(),
        remove: jest.fn(),
        constants: {
          W_OK: 2,
          R_OK: 4,
          F_OK: 0,
        },
      };

      // Replace fs-extra with mock
      jest.doMock("fs-extra", () => mockFs);
    });

    afterEach(() => {
      jest.clearAllMocks();
      jest.resetModules();
    });

    it("should handle invalid report content", async () => {
      await expect(
        reportGenerator.saveReport("", mockMetadata, "./test-output")
      ).rejects.toThrow("Invalid report content provided");
    });

    it("should handle invalid output path", async () => {
      await expect(
        reportGenerator.saveReport("valid report", mockMetadata, "")
      ).rejects.toThrow("Invalid output path provided");
    });

    it("should validate report content correctly", () => {
      const validReport = `# GitHub Issues Report: test - area

## Summary

Test content with sufficient length to pass validation checks.
This report contains the expected structure and format.`;

      const result = reportGenerator.validateReportContent(validReport);
      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it("should detect invalid report content", () => {
      const invalidReport = "Short";

      const result = reportGenerator.validateReportContent(invalidReport);
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        "Report content seems too short (less than 100 characters)"
      );
      expect(result.errors).toContain(
        "Report doesn't contain expected header format"
      );
      expect(result.errors).toContain("Report doesn't contain summary section");
    });

    it("should detect empty report content", () => {
      const result = reportGenerator.validateReportContent("");
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain("Report content is empty or invalid");
    });

    it("should detect null or undefined report content", () => {
      const result1 = reportGenerator.validateReportContent(null as any);
      expect(result1.isValid).toBe(false);
      expect(result1.errors).toContain("Report content is empty or invalid");

      const result2 = reportGenerator.validateReportContent(undefined as any);
      expect(result2.isValid).toBe(false);
      expect(result2.errors).toContain("Report content is empty or invalid");
    });

    it("should handle file system permission errors gracefully", async () => {
      const { ReportGenerator } = require("../report-generator");
      const generator = new ReportGenerator();

      // Mock fs operations to simulate permission error
      const mockError = new Error("Permission denied");
      (mockError as any).code = "EACCES";

      mockFs.ensureDir.mockRejectedValue(mockError);

      await expect(
        generator.saveReport(
          "valid report content",
          mockMetadata,
          "./test-output"
        )
      ).rejects.toThrow();
    });

    it("should handle disk space errors gracefully", async () => {
      const { ReportGenerator } = require("../report-generator");
      const generator = new ReportGenerator();

      // Mock fs operations to simulate disk space error
      const mockError = new Error("No space left on device");
      (mockError as any).code = "ENOSPC";

      mockFs.ensureDir.mockResolvedValue(undefined);
      mockFs.access.mockResolvedValue(undefined);
      mockFs.stat.mockResolvedValue({ isDirectory: () => true });
      mockFs.writeFile.mockRejectedValue(mockError);

      await expect(
        generator.saveReport(
          "valid report content",
          mockMetadata,
          "./test-output"
        )
      ).rejects.toThrow();
    });

    it("should handle directory creation errors", async () => {
      const { ReportGenerator } = require("../report-generator");
      const generator = new ReportGenerator();

      // Mock fs operations to simulate directory creation failure
      const mockError = new Error("Cannot create directory");
      mockFs.ensureDir.mockRejectedValue(mockError);

      await expect(
        generator.saveReport(
          "valid report content",
          mockMetadata,
          "./test-output"
        )
      ).rejects.toThrow();
    });

    it("should validate output path is a directory", async () => {
      const { ReportGenerator } = require("../report-generator");
      const generator = new ReportGenerator();

      // Mock fs operations to simulate file instead of directory
      mockFs.ensureDir.mockResolvedValue(undefined);
      mockFs.access.mockResolvedValue(undefined);
      mockFs.stat.mockResolvedValue({ isDirectory: () => false });

      await expect(
        generator.saveReport(
          "valid report content",
          mockMetadata,
          "./test-file.txt"
        )
      ).rejects.toThrow("Output path is not a directory");
    });

    it("should perform atomic file operations", async () => {
      const { ReportGenerator } = require("../report-generator");
      const generator = new ReportGenerator();

      const reportContent = "valid report content";

      // Mock successful fs operations
      mockFs.ensureDir.mockResolvedValue(undefined);
      mockFs.access.mockResolvedValue(undefined);
      mockFs.stat.mockResolvedValue({ isDirectory: () => true });
      mockFs.writeFile.mockResolvedValue(undefined);
      mockFs.move.mockResolvedValue(undefined);
      mockFs.readFile.mockResolvedValue(reportContent);

      const result = await generator.saveReport(
        reportContent,
        mockMetadata,
        "./test-output"
      );

      expect(mockFs.writeFile).toHaveBeenCalledWith(
        expect.stringContaining(".tmp"),
        reportContent,
        "utf8"
      );
      expect(mockFs.move).toHaveBeenCalledWith(
        expect.stringContaining(".tmp"),
        expect.stringContaining(".md"),
        { overwrite: true }
      );
      expect(result).toContain(".md");
    });

    it("should clean up temp files on error", async () => {
      const { ReportGenerator } = require("../report-generator");
      const generator = new ReportGenerator();

      // Mock fs operations to simulate error during move
      mockFs.ensureDir.mockResolvedValue(undefined);
      mockFs.access.mockResolvedValue(undefined);
      mockFs.stat.mockResolvedValue({ isDirectory: () => true });
      mockFs.writeFile.mockResolvedValue(undefined);
      mockFs.move.mockRejectedValue(new Error("Move failed"));
      mockFs.remove.mockResolvedValue(undefined);

      await expect(
        generator.saveReport(
          "valid report content",
          mockMetadata,
          "./test-output"
        )
      ).rejects.toThrow();

      expect(mockFs.remove).toHaveBeenCalledWith(
        expect.stringContaining(".tmp")
      );
    });

    it("should verify file write integrity", async () => {
      const { ReportGenerator } = require("../report-generator");
      const generator = new ReportGenerator();

      const reportContent = "valid report content";

      // Mock fs operations with content length mismatch
      mockFs.ensureDir.mockResolvedValue(undefined);
      mockFs.access.mockResolvedValue(undefined);
      mockFs.stat.mockResolvedValue({ isDirectory: () => true });
      mockFs.writeFile.mockResolvedValue(undefined);
      mockFs.move.mockResolvedValue(undefined);
      mockFs.readFile.mockResolvedValue("different content"); // Wrong content
      mockFs.remove.mockResolvedValue(undefined);

      await expect(
        generator.saveReport(reportContent, mockMetadata, "./test-output")
      ).rejects.toThrow("File write verification failed");
    });
  });
});
