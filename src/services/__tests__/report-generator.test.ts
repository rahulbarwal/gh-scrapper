import { ReportGenerator, ReportMetadata } from "../report-generator";
import { GitHubIssue, Config } from "../../models";

describe("ReportGenerator", () => {
  let reportGenerator: ReportGenerator;
  let mockIssues: GitHubIssue[];
  let mockMetadata: ReportMetadata;
  let mockConfig: Config;

  beforeEach(() => {
    reportGenerator = new ReportGenerator();

    // Mock data
    mockIssues = [
      {
        id: 123,
        title: "Authentication fails with OAuth",
        description:
          "Users are experiencing authentication failures when using OAuth flow. This is a critical issue affecting user login.",
        labels: ["bug", "authentication", "critical"],
        state: "open",
        createdAt: new Date("2024-01-15"),
        updatedAt: new Date("2024-01-20"),
        author: "user123",
        url: "https://github.com/test/repo/issues/123",
        comments: [],
        relevanceScore: 85,
        summary: "Critical authentication bug affecting OAuth login flow",
        workarounds: [
          {
            description: "Use API key authentication as temporary workaround",
            author: "maintainer1",
            authorType: "maintainer",
            commentId: 456,
            effectiveness: "confirmed",
          },
          {
            description: "Clear browser cache and try again",
            author: "user456",
            authorType: "user",
            commentId: 789,
            effectiveness: "suggested",
          },
        ],
      },
      {
        id: 456,
        title: "Performance issue with large datasets",
        description:
          "Application becomes slow when processing datasets larger than 10MB",
        labels: ["performance", "enhancement"],
        state: "open",
        createdAt: new Date("2024-01-10"),
        updatedAt: new Date("2024-01-18"),
        author: "developer1",
        url: "https://github.com/test/repo/issues/456",
        comments: [],
        relevanceScore: 72,
        summary: "Performance degradation with large data processing",
        workarounds: [],
      },
    ];

    mockMetadata = {
      repositoryName: "test-repo",
      repositoryUrl: "https://github.com/test/test-repo",
      productArea: "authentication",
      scrapeDate: new Date("2024-01-25T10:00:00Z"),
      totalIssuesAnalyzed: 100,
      relevantIssuesFound: 2,
      minRelevanceScore: 70,
      generatedBy: "GitHub Issue Scraper v1.0.0",
    };

    mockConfig = {
      githubToken: "test-token",
      repository: "test/test-repo",
      productArea: "authentication",
      maxIssues: 50,
      minRelevanceScore: 70,
      outputPath: "./reports",
    };
  });

  describe("generateReport", () => {
    it("should generate a complete report with all sections", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain(
        "# GitHub Issues Report: test-repo - authentication"
      );
      expect(report).toContain("## Summary");
      expect(report).toContain("## Table of Contents");
      expect(report).toContain("## Issues");
      expect(report).toContain("Issue #123: Authentication fails with OAuth");
      expect(report).toContain(
        "Issue #456: Performance issue with large datasets"
      );
    });

    it("should include metadata section with correct information", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain(
        "**Repository**: [test-repo](https://github.com/test/test-repo)"
      );
      expect(report).toContain("**Product Area**: authentication");
      expect(report).toContain("**Total Issues Analyzed**: 100");
      expect(report).toContain("**Relevant Issues Found**: 2");
      expect(report).toContain("**Minimum Relevance Score**: 70%");
      expect(report).toContain("**Generated By**: GitHub Issue Scraper v1.0.0");
    });

    it("should generate table of contents with correct links", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain(
        "1. [Issue #123: Authentication fails with OAuth](#authentication-fails-with-oauth) (85% relevance)"
      );
      expect(report).toContain(
        "2. [Issue #456: Performance issue with large datasets](#performance-issue-with-large-datasets) (72% relevance)"
      );
    });

    it("should sort issues by relevance score by default", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      const issue123Index = report.indexOf("Issue #123");
      const issue456Index = report.indexOf("Issue #456");

      // Issue 123 has higher relevance (85) so should come first
      expect(issue123Index).toBeLessThan(issue456Index);
    });

    it("should format issues with all required information", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      // Check issue formatting
      expect(report).toContain("**Status**: Open");
      expect(report).toContain("**Created**: 1/15/2024 by user123");
      expect(report).toContain("**Relevance Score**: 85/100");
      expect(report).toContain(
        "**Labels**: `bug`, `authentication`, `critical`"
      );
      expect(report).toContain(
        "**URL**: [View on GitHub](https://github.com/test/repo/issues/123)"
      );
    });

    it("should include workarounds with proper formatting", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain("#### Workarounds");
      expect(report).toContain("1. **👨‍💻 maintainer1** ✅");
      expect(report).toContain(
        "Use API key authentication as temporary workaround"
      );
      expect(report).toContain("2. **👤 user456** 💡");
      expect(report).toContain("Clear browser cache and try again");
    });

    it("should handle issues without workarounds", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      // Issue 456 has no workarounds
      const issue456Section = report.substring(report.indexOf("Issue #456"));
      expect(issue456Section).toContain(
        "*No workarounds found in the comments.*"
      );
    });

    it("should handle empty issues array", async () => {
      const emptyMetadata = {
        ...mockMetadata,
        relevantIssuesFound: 0,
      };

      const report = await reportGenerator.generateReport(
        [],
        emptyMetadata,
        mockConfig
      );

      expect(report).toContain("*No relevant issues found.*");
      expect(report).toContain(
        "*No relevant issues found. Consider broadening your search criteria or lowering the minimum relevance score.*"
      );
    });

    it("should respect options to exclude table of contents", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig,
        { includeTableOfContents: false }
      );

      expect(report).not.toContain("## Table of Contents");
    });

    it("should respect options to exclude metadata", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig,
        { includeMetadata: false }
      );

      expect(report).not.toContain("- **Repository**:");
      expect(report).not.toContain("- **Product Area**:");
      expect(report).not.toContain("- **Total Issues Analyzed**:");
    });

    it("should not sort by relevance when option is disabled", async () => {
      // Reverse the order to test
      const reversedIssues = [...mockIssues].reverse();

      const report = await reportGenerator.generateReport(
        reversedIssues,
        mockMetadata,
        mockConfig,
        { sortByRelevance: false }
      );

      const issue456Index = report.indexOf("1. Issue #456");
      const issue123Index = report.indexOf("2. Issue #123");

      expect(issue456Index).toBeLessThan(issue123Index);
    });
  });

  describe("filename generation", () => {
    it("should generate correct filename", () => {
      const filename = (reportGenerator as any).generateFilename(mockMetadata);
      const expectedFilename =
        "github-issues-test-repo-authentication-2024-01-25.md";
      expect(filename).toBe(expectedFilename);
    });

    it("should handle special characters in repository name", () => {
      const specialMetadata = {
        ...mockMetadata,
        repositoryName: "test@repo#name!",
        productArea: "auth & security",
      };

      const filename = (reportGenerator as any).generateFilename(
        specialMetadata
      );
      expect(filename).toContain(
        "github-issues-test-repo-name--auth---security-2024-01-25.md"
      );
    });
  });

  describe("createMetadata", () => {
    it("should create metadata from config and issues", () => {
      const metadata = ReportGenerator.createMetadata(
        mockConfig,
        mockIssues,
        150
      );

      expect(metadata.repositoryName).toBe("test-repo");
      expect(metadata.repositoryUrl).toBe("https://github.com/test/test-repo");
      expect(metadata.productArea).toBe("authentication");
      expect(metadata.totalIssuesAnalyzed).toBe(150);
      expect(metadata.relevantIssuesFound).toBe(2);
      expect(metadata.minRelevanceScore).toBe(70);
      expect(metadata.generatedBy).toBe("GitHub Issue Scraper v1.0.0");
      expect(metadata.scrapeDate).toBeInstanceOf(Date);
    });

    it("should handle repository URL formats", () => {
      const configWithUrl = {
        ...mockConfig,
        repository: "https://github.com/owner/repo",
      };

      const metadata = ReportGenerator.createMetadata(
        configWithUrl,
        mockIssues,
        100
      );

      expect(metadata.repositoryUrl).toBe("https://github.com/owner/repo");
      expect(metadata.repositoryName).toBe("repo");
    });

    it("should handle simple repository names", () => {
      const configWithSimpleName = {
        ...mockConfig,
        repository: "simple-repo",
      };

      const metadata = ReportGenerator.createMetadata(
        configWithSimpleName,
        mockIssues,
        100
      );

      expect(metadata.repositoryName).toBe("simple-repo");
      expect(metadata.repositoryUrl).toBe("https://github.com/simple-repo");
    });
  });

  describe("text truncation", () => {
    it("should truncate long descriptions", async () => {
      const longDescription = "A".repeat(1000);
      const issueWithLongDescription = {
        ...mockIssues[0],
        description: longDescription,
      };

      const report = await reportGenerator.generateReport(
        [issueWithLongDescription],
        mockMetadata,
        mockConfig
      );

      expect(report).toContain("...");
      expect(report).not.toContain("A".repeat(600));
    });
  });

  describe("author type and effectiveness icons", () => {
    it("should use correct icons for different author types", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain("👨‍💻"); // maintainer
      expect(report).toContain("👤"); // user
    });

    it("should use correct icons for different effectiveness levels", async () => {
      const report = await reportGenerator.generateReport(
        mockIssues,
        mockMetadata,
        mockConfig
      );

      expect(report).toContain("✅"); // confirmed
      expect(report).toContain("💡"); // suggested
    });
  });
});
